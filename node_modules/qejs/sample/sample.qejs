<%/* When all we are doing is outputting a promise for a string, we can just use it directly as if it was already resolved.
    The system will reserve a space for it and fill it in later.*/%>

<% if (names.length) { %>
  <ul>
    <% names.forEach(function(name){ %>
      <li><%=name%> isn't really <%=getAge(name)/*Async function*/%> years old, it's just that his/her name is <%= name.length %> letters long.</li>
    <% }) %>
  </ul>
<% } %>

<%/* We can also use the async block to reserve a space for a whole block of qejs.
    The syntax for that begins 'promise->identifer' and ends with '<'
    Inside the block, you can use the identifier to refer to the resolution of the promise. */%>

<p><% Q.all(names.map(getAge))->ages %>The average age of the group is <%- ages.reduce(function(a,v){return a+v})/ages.length -%>
<%  < /*Async block now closed*/%></p>

<%/* The comparison works here because we have resolved both forbes and dee.  
We could have done these as a pair of nested async blocks, but for convenience, 
we can use the array syntax (which translates to Q.all(input).spread(function(output){...}))
You can use the array syntax on one or both of the sides of the async starter declaration.
This lets you use Q.all without spread, or spread without Q.all
  */%>
<p><% [getAge('Forbes'), getAge('Dee')] -> [forbes,dee] %><%if(forbes>dee){%>This failed aproximation makes it look as if Forbes (<%=forbes%>) is older than Dee (<%=dee%>)<%
}else{%>This failed aproximation makes it look as if Forbes (<%=forbes%>) is younger than Dee(<%=dee%>)<% }< %></p>